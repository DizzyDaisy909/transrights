use crate::ast::*;

grammar;

pub Selector: Selector = {
    <i:Identifier> ":" <s:Statement> => Selector{selector: i, value: s}
};

pub SelectorList: Vec<Selector> = {
    <sl:SelectorList> <s:Selector> => [sl, vec![s]].concat(),
    <s:Selector> => vec![s],
}

pub Message: Statement = {
    "(" <i:Identifier> <s:SelectorList> ")" => Statement::Message(i, s),
};

pub Literal: Statement = {
    <x:r#"`[^`]*`"#> => Statement::Literal(Literal::Str(x[1..(x.len() - 1)].to_string())),
};

pub VarDeclaration: Statement = {
    <i:Identifier> ":=" <s:Statement> => Statement::VarDeclaration(i, s)
};

pub VarDefinition: Statement = {
    <i:Identifier> "=" <s:Statement> => Statement::VarDefinition(i, s)
};

pub Identifier: String = {
    r"[a-zA-Z][0-9a-zA-Z]+" => <>.to_string(),
};

pub Argument: Argument = {
    <i1:Identifier> ":" <i2:Identifier> => Argument{name: i1, kind: i2}
};

pub ArgumentList: Vec<Argument> = {
    <al:ArgumentList> <a:Argument> => [al, vec![a]].concat(),
    <a:Argument> => vec![a],
}

pub Function: Statement = {
    "func" <i:Identifier> <al:ArgumentList> "replies" <r:Identifier> "{"
        <sl: StatementList>
    "}" => Statement::Function(Function{name: i, arguments: al, replies: r, statements: sl})
};

pub Statement: Box<Statement> = {
    <m:Message> => Box::new(m),
    <l:Literal> => Box::new(l),
    <i:Identifier> => Box::new(Statement::Ident(i)),
    <v:VarDeclaration> => Box::new(v),
    <v:VarDefinition> => Box::new(v),
    <f:Function> => Box::new(f),
    "()" => Box::new(Statement::NOOP),
};

pub StatementList: Vec<Box<Statement>> = {
    <s:Statement> => vec![s],
    <sl:StatementList> ";" => sl,
    <sl:StatementList> ";" <s:Statement> => [sl, vec![s]].concat(),
};

